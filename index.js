// Generated by CoffeeScript 1.9.3
(function() {
  var chalk, fetchSourceCode;

  chalk = require('chalk');

  module.exports.log = console.log.bind(console);

  module.exports.setTitle = function(title) {
    process.stdout.write('\x1b]0;' + title + '\x07');
    return process.stdout.write('\x1b]2;' + title + '\x07');
  };

  module.exports.reportException = function(where, e) {
    module.exports.reportError(where, e);
    process.exit(1);
    return false;
  };

  module.exports.reportError = function(where, e) {
    var charNum, displayFilename, filename, fn, i, len, line, lineNum, lines, m, newLine, reCode, reNoSpace, rePromise1, rePromise2, sourceCode, str, strResult;
    module.exports.log("-----------------------------------------------------------------------------------------------------");
    module.exports.log(chalk.blue("Exception in   : " + chalk.yellow(where)));
    if (e != null) {
      module.exports.log(chalk.blue("Exception text : " + chalk.green(e.toString())));
    }
    if ((e != null) && (e.stack != null)) {
      str = e.stack;
      rePromise1 = new RegExp("node_modules.co.*");
      rePromise2 = new RegExp("\\(native\\)");
      reCode = new RegExp("at([^/]+)\\(*(.*.coffee):([0-9]+):([0-9]+).*", "i");
      reNoSpace = new RegExp("[ \\(]", "g");
      sourceCode = null;
      strResult = "";
      lines = str.split(/\n/);
      for (i = 0, len = lines.length; i < len; i++) {
        line = lines[i];
        if (rePromise1.test(line)) {
          continue;
        }
        if (rePromise2.test(line)) {
          continue;
        }
        m = line.match(reCode);
        if (m != null) {
          fn = m[1];
          filename = m[2];
          lineNum = parseInt(m[3]);
          charNum = parseInt(m[4]);
          fn = fn.replace(reNoSpace, "");
          displayFilename = filename.replace(/^.*\//, "");
          if ((fn != null) && fn.length) {
            newLine = "  at " + chalk.yellow(fn) + " ";
          } else {
            newLine = "  ";
          }
          newLine += "in " + chalk.red(displayFilename) + (":" + lineNum + " +" + charNum);
          if (sourceCode == null) {
            sourceCode = fetchSourceCode(filename, lineNum, charNum);
            line = sourceCode + newLine;
          } else {
            line = newLine;
          }
        }
        strResult += line + "\n";
      }
      module.exports.log(chalk.cyan(strResult));
    }
    module.exports.log("-----------------------------------------------------------------------------------------------------");
    return false;
  };

  if (module.exports.initialized == null) {
    module.exports.initialized = true;
    process.on('uncaughtException', (function(_this) {
      return function(err) {
        return module.exports.reportException("Uncaught Exception", err);
      };
    })(this));
    process.on('unhandledRejection', (function(_this) {
      return function(err) {
        return module.exports.reportException("Unhandled Rejection", err);
      };
    })(this));
  }

  fetchSourceCode = function(filename, lineNum, charPos) {
    var a, cs_lines, e, i, j, maxLine, minLine, n, ref, ref1, source, str, strNum;
    try {
      minLine = lineNum - 3;
      maxLine = lineNum + 3;
      str = "\n";
      source = fs.readFileSync(filename).toString('utf8');
      cs_lines = source.split('\n');
      for (n = i = 0, ref = cs_lines.length; 0 <= ref ? i < ref : i > ref; n = 0 <= ref ? ++i : --i) {
        if (n >= minLine && n <= maxLine) {
          strNum = n + " |";
          while (strNum.length < 6) {
            strNum = " " + strNum;
          }
          if (n === lineNum - 1) {
            strNum = chalk.bold.white(" > ") + chalk.bold.cyan(strNum);
          } else {
            strNum = "   " + strNum;
          }
          str += strNum;
          if (n === lineNum - 1) {
            str += chalk.bold.gray(cs_lines[n]);
            str += "\n              ";
            for (a = j = 0, ref1 = charPos; 0 <= ref1 ? j < ref1 : j > ref1; a = 0 <= ref1 ? ++j : --j) {
              str += " ";
            }
            str += chalk.bold.red("^");
          } else {
            str += chalk.gray(cs_lines[n]);
          }
          str += "\n";
        }
      }
      str += "\n";
      return str;
    } catch (_error) {
      e = _error;
      return "";
    }
  };

}).call(this);
